<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <title>–ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä –ú–µ—Ä–µ–∂</title>
  <style>
     body {
      font-family: Arial, sans-serif;
      margin: 0; padding: 0;
      background: linear-gradient(135deg, #006400, #004d00);
      color: #ffffff;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    table { border-collapse: collapse; width: 100%; margin-top: 20px; }
    th, td { border: 1px solid #7a7a7a; padding: 6px; text-align: center; }
    th { background: #adadad; }
    td.name { text-align: left; }
    .vital { background-color: #26a12b; }
    .valuable { background-color: #286ca3; }
    .acceptable { background-color: #e0d037; }
    .interfering { background-color: #c78a90; }
    label {
      display: block; margin: 10px auto 5px auto; font-weight: bold;
      width: 500px; text-align: left;
    }
    input {
      width: 500px; padding: 10px; margin: 5px auto 15px auto;
      border: none; border-radius: 6px; font-size: 1rem;

    }
    select {
      width: 500px; padding: 10px; margin: 5px auto 15px auto;
      border: none; border-radius: 6px; font-size: 1rem;
    }
    button {
      width: 200px; padding: 12px; margin-top: 10px;
      background-color: #004d00; color: #ffffff;
      border: solid 1px #c2ffc2; border-radius: 6px; font-size: 1rem;
      cursor: pointer; transition: background 0.3s ease;
    }
     h3 { margin-top: 30px; text-align: center; }
    button:hover { background-color: #003300; }
/* —Å—Ç–∏–ª—ñ –¥–ª—è —Ç–∞–±–ª–∏—Ü—ñ */
td.to-sell {
  text-align: center;
  font-weight: bold;
  color: white;
}

     
  </style>
</head>
<body>
  <h1>–ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä —Ä–æ–∑–ø–æ–¥—ñ–ª—É –ø–ª–∞–Ω—É</h1>
<br><br>
  <img src="./logo.svg" alt="logo" width="560">
  <label>–°–ø—ñ–≤—Ä–æ–±—ñ—Ç–Ω–∏–∫:
    <select id="userSelect">
      <option value="fedir">–û–ª–µ–∫—Å–∞–Ω–¥—Ä</option>
      <option value="olena">–¢–µ—Ç—è–Ω–∞</option>
      
    </select>
  </label>
  <label>–ü–∞—Ä—Ç–Ω–µ—Ä:
    <select id="partnerSelect"></select>
  </label>
  <label>–ö–≤–∞—Ä—Ç–∞–ª:
    <select id="quarterSelect">
      <option value="Q1">Q1</option>
      <option value="Q2">Q2</option>
      <option value="Q3">Q3</option>
      <option value="Q4">Q4</option>
    </select>
  </label>
  <label>–¢–∏–ø —ñ—Å—Ç–æ—Ä—ñ—ó:
    <select id="historyType">
      <option value="money">–ì—Ä–æ—à—ñ</option>
      <option value="packs">–£–ø–∞–∫–æ–≤–∫–∏</option>
    </select>
  </label>
  <button id="calcBtn">–†–æ–∑—Ä–∞—Ö—É–≤–∞—Ç–∏</button>
  <div id="totals"></div>
  <div id="allPartnersClassification"></div>
  <div id="classification"></div>
  <div id="historyPlans"></div>

<canvas id="planChart" width="400" height="200"></canvas>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script type="module">
const userMap = {
  fedir: [9,798,31,15,41,26,32,66,47,17,121,61,52,76,29,22,94,23,16,55],
  olena: [11,53,45,146,181,27,601,108,10],
  office: [1,2,3,4,5,6]
};

// –í–∏–±—ñ—Ä —Ç–∞–±–ª–∏—Ü—ñ —ñ—Å—Ç–æ—Ä—ñ—ó –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
function getHistoryUrl(user) {
  if (user === "fedir" || user === "office") {
    return "https://docs.google.com/spreadsheets/d/1OhWc6BKpVML_dnxDVTvLsr6GyRfM27BZ";
  } else if (user === "olena") {
    return "https://docs.google.com/spreadsheets/d/1EeL08aCAa5PCwIYAtN49hQQibp5otMEm";
  }
  return null;
}

// –¢—è–≥–Ω–µ–º–æ –¥–∞–Ω—ñ –∑ –ú–æ—Ä—ñ–æ–Ω—É (–ø–æ–≤–Ω–∏–π —Å–ø–∏—Å–æ–∫)
async function fetchPartners(morionUrl) {
  const url = `${morionUrl}/gviz/tq?tqx=out:json&sheet=sheet1`;
  const res = await fetch(url);
  const text = await res.text();
  const json = JSON.parse(text.substr(47).slice(0, -2));

  return json.table.rows.map(r => {
    const corpRaw = r.c[0]?.v || "";
    const idMatch = corpRaw.match(/^(\d+)/);
    const id = idMatch ? parseInt(idMatch[1]) : 0;
    const name = corpRaw.replace(/^(\d+)\.\s*/, "");

    let grossRaw = r.c[3]?.v;
    let grossRate = parseFloat(grossRaw);
    if (isNaN(grossRate)) grossRate = 0;
    grossRate = grossRate * 100;

    return {
      id,
      name,
      turnover: parseFloat(r.c[1]?.v) || 0,
      msTable: parseFloat(r.c[2]?.v) || 0,
      grossRate,
      ei: parseFloat(r.c[4]?.v) || 0,
      tt: parseInt(r.c[5]?.v) || 0
    };
  }).filter(p => p.id && p.name && !p.name.includes("Rating"));
}

// –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –ø–∞—Ä—Ç–Ω–µ—Ä—ñ–≤ —Ç—ñ–ª—å–∫–∏ –∑ userMap
async function initPartners(user) {
  const morionUrl = "https://docs.google.com/spreadsheets/d/1CUEcXgBAUIKvg0k2JePbhSH-_S01HcEi";
  const partners = await fetchPartners(morionUrl);

  localStorage.setItem("partners", JSON.stringify(partners));

  const ids = userMap[user] || [];
  const filtered = partners.filter(p => ids.includes(p.id));

  const partnerSelect = document.getElementById("partnerSelect");
  partnerSelect.innerHTML = `<option value="all">–í—Å—ñ –ø–∞—Ä—Ç–Ω–µ—Ä–∏</option>`;
  filtered.forEach(p => {
    partnerSelect.innerHTML += `<option value="${p.id}">${p.name}</option>`;
  });

  console.log("‚ñ∂ initPartners: –∑–±–µ—Ä–µ–∂–µ–Ω–æ –ø–∞—Ä—Ç–Ω–µ—Ä—ñ–≤", filtered.length);
}

// –î–æ–ø–æ–º—ñ–∂–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥—É —á–∏—Å–µ–ª
function parseNum(v) {
  if (v === null || v === "" || v === undefined) return 0;
  const num = parseFloat(String(v).replace(/\s/g, "")); // –ø—Ä–∏–±–∏—Ä–∞—î–º–æ –ø—Ä–æ–±—ñ–ª–∏
  return isNaN(num) ? 0 : num;
}

async function fetchHistory(partnerId, historyUrl, partnerData) {
  const partnerName = partnerData.find(p => p.id === partnerId)?.name || `–ü–∞—Ä—Ç–Ω–µ—Ä ${partnerId}`;
  const url = `${historyUrl}/gviz/tq?tqx=out:json&range='${partnerId}'!A1:Z1000`;
  const res2 = await fetch(url);
  const text2 = await res2.text();
  const json2 = JSON.parse(text2.substr(47).slice(0, -2));

  const cols = json2.table.cols.map(c => c.label);
  const rows = json2.table.rows.map(r => r.c.map(c => c?.v || ""));

  let products = [];
  let mode = "money";
  let firstProduct = null;
  let seenFirstAgain = false;

rows.forEach(r => {
  const product = r[2]; // –∫–æ–ª–æ–Ω–∫–∞ C
  if (!product || product === "–¢–æ–≤–∞—Ä–¥–ª—è–ü–ª–∞–Ω–∞" || product === "–í—Å—å–æ–≥–æ") return;

  if (!firstProduct) {
    firstProduct = product;
  } else if (product === firstProduct && !seenFirstAgain) {
    mode = "packs";
    seenFirstAgain = true;
    console.log("‚ñ∂ –ü–µ—Ä–µ—Ö—ñ–¥ –Ω–∞ –±–ª–æ–∫ —É–ø–∞–∫–æ–≤–æ–∫ –¥–ª—è –ø–∞—Ä—Ç–Ω–µ—Ä–∞", partnerId);
  }

  let prod = products.find(p => p.product === product);
  if (!prod) {
    prod = { partnerId, partnerName, product, historyMoney: {}, historyPacks: {} };
    products.push(prod);
  }

  cols.forEach((col, idx) => {
    // –±–µ—Ä–µ–º–æ –∫–≤–∞—Ä—Ç–∞–ª–∏ 2025 —ñ 2026
    if (/^202[56]_\d$/.test(col)) {
      const val = Math.round(parseNum(r[idx])); // –æ–∫—Ä—É–≥–ª—é—î–º–æ –¥–æ —Ü—ñ–ª–∏—Ö
      if (mode === "money") {
        prod.historyMoney[col] = val;
      } else {
        prod.historyPacks[col] = val;
      }
    }
  });
});

  console.log("‚ñ∂ fetchHistory: —Ä–µ–∑—É–ª—å—Ç–∞—Ç", products);
  return products;
}
// ... —Ç–≤—ñ–π userMap, getHistoryUrl, fetchPartners, initPartners, parseNum, fetchHistory ...
async function fetchPlan(planUrl) {
  const url = `${planUrl}/gviz/tq?tqx=out:json&sheet=sheet1`;
  const res = await fetch(url);
  const text = await res.text();
  const json = JSON.parse(text.substr(47).slice(0, -2));

  const rows = json.table.rows.map(r => r.c.map(c => c?.v || ""));

  return rows.map(r => {
    const product = r[0];
    if (!product) return null;

    return {
      product,
      planMoney: {
        "2026_1": parseFloat(r[1]) || 0,
        "2026_2": parseFloat(r[2]) || 0,
        "2026_3": parseFloat(r[3]) || 0,
        "2026_4": parseFloat(r[4]) || 0
      },
      planPacks: {
        "2026_1": parseFloat(r[5]) || 0,
        "2026_2": parseFloat(r[6]) || 0,
        "2026_3": parseFloat(r[7]) || 0,
        "2026_4": parseFloat(r[8]) || 0
      }
    };
  }).filter(Boolean);
}

// –ö–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—è –ø–∞—Ä—Ç–Ω–µ—Ä–∞
function classifyPartner(p, allPartners) {
  // —Å—É–º–∞ —ñ—Å—Ç–æ—Ä—ñ—ó –ø–æ –≥—Ä–æ—à–∞—Ö
  const totalHistory = p.products.reduce((sum, prod) => {
    const vals = Object.values(prod.historyMoney || {});
    return sum + vals.reduce((s,v)=>s+v,0);
  }, 0);

  // —Å–µ—Ä–µ–¥–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è –ø–æ –≤—Å—ñ—Ö –ø–∞—Ä—Ç–Ω–µ—Ä–∞—Ö
  const avgHistory = allPartners.reduce((s,x)=>{
    const h = x.products.reduce((sum, prod) => {
      const vals = Object.values(prod.historyMoney || {});
      return sum + vals.reduce((s,v)=>s+v,0);
    },0);
    return s+h;
  },0) / allPartners.length;

  const avgMsr = allPartners.reduce((s,x)=>s+(x.msr||0),0) / allPartners.length;

  const highHistory = totalHistory >= avgHistory;
  const highMsr = p.msr >= avgMsr;

  if (highHistory && highMsr) return {type:"–ñ–∏—Ç—Ç—î–≤–æ –≤–∞–∂–ª–∏–≤–∏–π", cls:"vital"};
  if (!highHistory && highMsr) return {type:"–¶—ñ–Ω–Ω–∏–π", cls:"valuable"};
  if (highHistory && !highMsr) return {type:"–ü—Ä–∏–π–Ω—è—Ç–Ω–∏–π", cls:"acceptable"};
  return {type:"–ó–∞–≤–∞–∂–∞—é—á–∏–π", cls:"interfering"};
}
;

// –ú–∞–ø—ñ–Ω–≥ –∫–ª—é—á—ñ–≤ userMap ‚Üí —ñ–º–µ–Ω–∞ —Å–ø—ñ–≤—Ä–æ–±—ñ—Ç–Ω–∏–∫—ñ–≤
const userNames = {
  fedir: "–û–ª–µ–∫—Å–∞–Ω–¥—Ä",
  olena: "–¢–µ—Ç—è–Ω–∞",
  office: "–û—Ñ—ñ—Å"
};

function calculateUserTotals(planRows, partners, quarter, userKey) {
  const ids = userMap[userKey];
  const historyKey = `2025_${quarter.replace("Q","")}`;
  const execKey1   = `2026_${quarter.replace("Q","")}`;
  const execKey2   = `2026_Q${quarter.replace("Q","")}`;
  const planKey1   = `2026_${quarter.replace("Q","")}`;
  const planKey2   = `2026_Q${quarter.replace("Q","")}`;

  let totalHistory = 0;
  let totalExec = 0;

  // –Ü—Å—Ç–æ—Ä—ñ—è –ø–æ –ø–∞—Ä—Ç–Ω–µ—Ä–∞—Ö
  partners.forEach(p => {
    if (!ids.includes(p.id)) return;
    if (!Array.isArray(p.products)) return;

    p.products.forEach(prod => {
      totalHistory += prod.historyMoney?.[historyKey] || 0;
      totalExec    += prod.historyMoney?.[execKey1] || prod.historyMoney?.[execKey2] || 0;
    });
  });

  // –ü–ª–∞–Ω –≤–ª–∞—Å–Ω–∏–∫–∞ (—Å—É–º–∞ –ø–æ –≤—Å—ñ—Ö –ø—Ä–æ–¥—É–∫—Ç–∞—Ö)
  let totalPlan = 0;
  planRows.forEach(row => {
    totalPlan += row.planMoney?.[planKey1] || row.planMoney?.[planKey2] || 0;
  });

  const percentExec = totalPlan > 0 ? ((totalExec / totalPlan) * 100).toFixed(2) : "0.00";

  return {
    totalHistory: Math.round(totalHistory),
    totalPlan: Math.round(totalPlan),
    totalExec: Math.round(totalExec),
    percentExec
  };
}



// –§–æ—Ä–º—É–ª–∞ –ø–ª–∞–Ω—ñ–≤
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}

function formatPlan(value, history) {
  const roundedValue = Math.ceil(value);
  const delta = history > 0 ? Math.ceil(((value - history) / history * 100)) : 0;
  const sign = delta >= 0 ? "+" : "";
  return `${roundedValue} / ${sign}${delta}%`;
}

function distributePlanForPartners(plans, partners, quarter) {
  const keyPrev = `2025_${quarter.replace("Q","")}`; // —ñ—Å—Ç–æ—Ä—ñ—è
  const keyCurr = `2026_${quarter.replace("Q","")}`; // –≤–∏–∫–æ–Ω–∞–Ω–æ

  plans.forEach(plan => {
    let weights = partners.map(p => {
      const historyProd = p.products.find(prod => prod.product === plan.product);
      const historyValue = historyProd ? (historyProd.historyPacks?.[keyPrev] || 0) : 0;

      const eiPercent = (p.ei - 100);
      let growthFactor = (p.grossRate + eiPercent) / 2;
      growthFactor = clamp(growthFactor, -10, 50);

      let typeCoef = 1.0;
      switch(p.type) {
        case "–ñ–∏—Ç—Ç—î–≤–æ –≤–∞–∂–ª–∏–≤–∏–π": typeCoef = 1.4; break;
        case "–¶—ñ–Ω–Ω–∏–π": typeCoef = 1.0; break;
        case "–ü—Ä–∏–π–Ω—è—Ç–Ω–∏–π": typeCoef = 0.7; break;
        case "–ó–∞–≤–∞–∂–∞—é—á–∏–π": typeCoef = 0.3; break;
      }

      return { partner: p, weight: (historyValue + 1) * typeCoef * (1 + growthFactor/100), historyValue };
    });

    const totalMoney = plan.planMoney[keyCurr] || 0;
    const totalPacks = plan.planPacks[keyCurr] || 0;
    const sumWeights = weights.reduce((s,w)=>s+w.weight,0);

    weights.forEach(w => {
      const sharePacks = sumWeights > 0 ? (w.weight / sumWeights) * totalPacks : 0;
      let prod = w.partner.products.find(pr => pr.product === plan.product);

      if (prod) {
        // —ñ—Å—Ç–æ—Ä—ñ—è —ñ –≤–∏–∫–æ–Ω–∞–Ω–æ
        const historyPacks = prod.historyPacks?.[keyPrev] || 0;
        const execPacks    = prod.historyPacks?.[keyCurr] || 0;

        let planPacks = Math.ceil(sharePacks);
        planPacks = Math.max(planPacks, historyPacks);

        const toSellPacks = Math.max(planPacks - execPacks, 0);

        prod.planPacks   = planPacks;
        prod.execPacks   = execPacks;
        prod.toSellPacks = toSellPacks;

        prod.basePacks    = formatPlan(planPacks, historyPacks);
        prod.superPacks   = formatPlan(planPacks * 1.20, historyPacks);
        prod.optimalPacks = formatPlan(planPacks * 1.15, historyPacks);
        prod.satisfyPacks = formatPlan(planPacks * 1.07, historyPacks);
        prod.thinkPacks   = formatPlan(planPacks, historyPacks);
        prod.goPacks      = formatPlan(planPacks, historyPacks);

        const historyMoney = prod.historyMoney?.[keyPrev] || 0;
        const execMoney    = prod.historyMoney?.[keyCurr] || 0;

        const pricePerPack = totalPacks > 0 ? (totalMoney / totalPacks) : 0;
        let planMoney = planPacks * pricePerPack;
        planMoney = Math.max(planMoney, historyMoney);

        const toSellMoney = Math.max(planMoney - execMoney, 0);

        prod.planMoney   = Math.round(planMoney);
        prod.execMoney   = execMoney;
        prod.toSellMoney = Math.round(toSellMoney);

        prod.baseMoney    = formatPlan(planMoney, historyMoney);
        prod.superMoney   = formatPlan(planMoney * 1.20, historyMoney);
        prod.optimalMoney = formatPlan(planMoney * 1.15, historyMoney);
        prod.satisfyMoney = formatPlan(planMoney * 1.07, historyMoney);
        prod.thinkMoney   = formatPlan(planMoney, historyMoney);
        prod.goMoney      = formatPlan(planMoney, historyMoney);

        prod.percentExecPacks = planPacks > 0 ? ((execPacks / planPacks) * 100).toFixed(2) : "0.00";
        prod.percentExecMoney = planMoney > 0 ? ((execMoney / planMoney) * 100).toFixed(2) : "0.00";
      }
    });
  });

  return partners;
}

// –†–µ–Ω–¥–µ—Ä –∫–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—ó
function renderClassification(partners) {
  let html = "<h3>–ö–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—è –ø–∞—Ä—Ç–Ω–µ—Ä–∞</h3>";
  html += "<table><tr><th>–ù–∞–∑–≤–∞</th><th>–¢–æ–≤–∞—Ä–æ–æ–±—ñ–≥</th><th>MS%—Ç</th><th>MS—Ä%</th><th>Gross Rate</th><th>EI</th><th>–¢–¢</th><th>–¢–∏–ø –∫–ª—ñ—î–Ω—Ç–∞</th></tr>";

  partners.forEach(p => {
    html += `<tr>
      <td>${p.name}</td>
      <td>${p.turnover ? p.turnover.toFixed(2) : 0}</td>
      <td>${p.msTable ? p.msTable.toFixed(2) : 0}%</td>
      <td>${p.msr ? p.msr.toFixed(2) : 0}%</td>
      <td>${p.grossRate ? p.grossRate.toFixed(2) : 0}%</td>
      <td>${p.ei ? Math.round(p.ei) : 0}</td>
      <td>${p.tt || 0}</td>

      <td class="${p.cls}">${p.type}</td>
    </tr>`;
  });

  html += "</table>";
  document.getElementById("classification").innerHTML = html;
}

// –†–µ–Ω–¥–µ—Ä —ñ—Å—Ç–æ—Ä—ñ—ó —Ç–∞ –ø–ª–∞–Ω—ñ–≤
function renderHistoryPlans(partners, quarter, historyType) {
  let html = "<h3>–Ü—Å—Ç–æ—Ä—ñ—è —Ç–∞ –ø–ª–∞–Ω–∏</h3>";
  html += "<table><tr>"
        + "<th>–ü–∞—Ä—Ç–Ω–µ—Ä</th>"
        + "<th>–ü—Ä–æ–¥—É–∫—Ç</th>"
        + "<th>–Ü—Å—Ç–æ—Ä—ñ—è</th>"
        + "<th>–ü–ª–∞–Ω</th>"
        + "<th>–í–∏–∫–æ–Ω–∞–Ω–æ</th>"
        + "<th>–î–æ–ø—Ä–æ–¥–∞—Ç–∏</th>"
        + "<th>–î–æ–ª—å–æ–≤–∏–π</th>"
        + "<th>–°—É–ø–µ—Ä</th>"
        + "<th>–û–ø—Ç–∏–º–∞–ª—å–Ω–∏–π</th>"
        + "<th>–ó–∞–¥–æ–≤—ñ–ª—å–Ω–∏—Ç—å</th>"
        + "<th>–ü–æ–¥—É–º–∞—Ç–∏</th>"
        + "<th>–ü—ñ—Ç–∏</th>"
        + "</tr>";

  const keyPrev = `2025_${quarter.replace("Q","")}`;

  partners.forEach(p => {
    p.products.forEach(prod => {
      const history = historyType === "money"
        ? (prod.historyMoney?.[keyPrev] || 0)
        : (prod.historyPacks?.[keyPrev] || 0);

      const plan = historyType === "money"
        ? (prod.planMoney || 0)
        : (prod.planPacks || 0);

      const exec = historyType === "money"
        ? (prod.execMoney || 0)
        : (prod.execPacks || 0);

      const toSell = historyType === "money"
        ? (prod.toSellMoney || 0)
        : (prod.toSellPacks || 0);

      const base = historyType === "money" ? prod.baseMoney : prod.basePacks;
      const superV = historyType === "money" ? prod.superMoney : prod.superPacks;
      const optimal = historyType === "money" ? prod.optimalMoney : prod.optimalPacks;
      const satisfy = historyType === "money" ? prod.satisfyMoney : prod.satisfyPacks;
      const think = historyType === "money" ? prod.thinkMoney : prod.thinkPacks;
      const go = historyType === "money" ? prod.goMoney : prod.goPacks;

      const ratio = plan > 0 ? Math.min(toSell / plan, 1) : 1;
      const hue = (1 - ratio) * 120;
      const bgColor = `hsl(${hue}, 70%, 45%)`;

      html += `<tr>
        <td>${p.name}</td>
        <td>${prod.product}</td>
        <td>${history}</td>
        <td>${plan || "-"}</td>
        <td>${exec || "-"}</td>
        <td style="background-color:${bgColor};color:white;font-weight:bold;">${toSell || "-"}</td>
        <td>${base || "-"}</td>
        <td>${superV || "-"}</td>
        <td>${optimal || "-"}</td>
        <td>${satisfy || "-"}</td>
        <td>${think || "-"}</td>
        <td>${go || "-"}</td>
      </tr>`;
    });
  });

  html += "</table>";
  document.getElementById("historyPlans").innerHTML = html;
}


function renderAllPartnersClassification(partners) {
  let html = "<h3>–ö–ª–∞—Å–∏—Ñ—ñ–∫–∞—Ü—ñ—è –≤—Å—ñ—Ö –ø–∞—Ä—Ç–Ω–µ—Ä—ñ–≤ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞</h3>";
  html += "<table><tr><th>ID</th><th>–ù–∞–∑–≤–∞</th><th>–¢–æ–≤–∞—Ä–æ–æ–±—ñ–≥</th><th>MS%—Ç</th><th>MS—Ä%</th><th>Gross Rate</th><th>EI</th><th>–¢–¢</th><th>–°—É–º–∞ —ñ—Å—Ç–æ—Ä—ñ—ó</th><th>–¢–∏–ø –∫–ª—ñ—î–Ω—Ç–∞</th></tr>";

  partners.forEach(p => {
    // —Ä–∞—Ö—É—î–º–æ —Å—É–º—É —ñ—Å—Ç–æ—Ä—ñ—ó –ø–æ –≤—Å—ñ—Ö –ø—Ä–æ–¥—É–∫—Ç–∞—Ö
    const totalHistory = p.products.reduce((sum, prod) => {
      const vals = Object.values(prod.historyMoney || {});
      return sum + vals.reduce((s,v)=>s+v,0);
    }, 0);

    html += `<tr>
      <td>${p.id}</td>
      <td>${p.name}</td>
      <td>${p.turnover ? p.turnover.toFixed(2) : 0}</td>
      <td>${p.msTable ? p.msTable.toFixed(2) : 0}%</td>
      <td>${p.msr ? p.msr.toFixed(2) : 0}%</td>
      <td>${p.grossRate ? p.grossRate.toFixed(2) : 0}%</td>
      <td>${p.ei ? Math.round(p.ei) : 0}</td>
      <td>${p.tt || 0}</td>
      <td>${Math.round(totalHistory)}</td>
      <td class="${p.cls}">${p.type}</td>
    </tr>`;
  });

  html += "</table>";
  document.getElementById("allPartnersClassification").innerHTML = html;
}
let planChartInstance; // –≥–ª–æ–±–∞–ª—å–Ω–∞ –∑–º—ñ–Ω–Ω–∞ –¥–ª—è –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è –≥—Ä–∞—Ñ—ñ–∫–∞

function renderPlanChart(planRows, partners, quarter, userKey) {
  const ids = userMap[userKey];
  const execKey1 = `2026_${quarter.replace("Q","")}`;
  const execKey2 = `2026_Q${quarter.replace("Q","")}`;
  const planKey1 = `2026_${quarter.replace("Q","")}`;
  const planKey2 = `2026_Q${quarter.replace("Q","")}`;

  const labels = [];
  const data = [];

  planRows.forEach(row => {
    const plan = row.planMoney?.[planKey1] || row.planMoney?.[planKey2] || 0;

    let exec = 0;
    partners.forEach(p => {
      if (!ids.includes(p.id)) return;
      if (!Array.isArray(p.products)) return;

      p.products.forEach(prod => {
        if (prod.product === row.product) {
          exec += prod.historyMoney?.[execKey1] || prod.historyMoney?.[execKey2] || 0;
        }
      });
    });

    if (plan > 0) {
      labels.push(row.product);
      data.push(((exec / plan) * 100).toFixed(2));
    }
  });

  const ctx = document.getElementById("planChart").getContext("2d");

  // üîπ –ó–Ω–∏—â—É—î–º–æ —Å—Ç–∞—Ä–∏–π –≥—Ä–∞—Ñ—ñ–∫, —è–∫—â–æ –≤—ñ–Ω —ñ—Å–Ω—É—î
  if (planChartInstance) {
    planChartInstance.destroy();
  }

  planChartInstance = new Chart(ctx, {
    type: "bar",
    data: {
      labels: labels,
      datasets: [{
        label: "% –≤–∏–∫–æ–Ω–∞–Ω–Ω—è –ø–æ –ø—Ä–æ–¥—É–∫—Ç–∞—Ö",
        data: data,
        backgroundColor: "rgba(173, 216, 230, 1)", // —Å–≤—ñ—Ç–ª—ñ —Å—Ç–æ–≤–ø—á–∏–∫–∏
        borderColor: "rgba(173, 216, 230, 1)",     // —Å–≤—ñ—Ç–ª—ñ –º–µ–∂—ñ
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      plugins: {
        legend: {
          labels: {
            color: "white",
            font: { weight: "bold" }
          }
        },
        title: {
          display: true,
          text: "% –≤–∏–∫–æ–Ω–∞–Ω–Ω—è –ø–æ –ø—Ä–æ–¥—É–∫—Ç–∞—Ö",
          color: "white",
          font: { weight: "bold", size: 16 }
        }
      },
      scales: {
        x: {
          ticks: {
            color: "white",
            font: { weight: "bold" }
          }
        },
        y: {
          beginAtZero: true,
          max: 120,
          ticks: {
            color: "white",
            font: { weight: "bold" },
            callback: function(value) { return value + "%"; }
          }
        }
      }
    }
  });
}
function getColorForToSell(toSell, plan) {
  if (plan <= 0) return "gray";
  const ratio = Math.min(toSell / plan, 1); // –≤—ñ–¥ 0 –¥–æ 1
  // –∑–µ–ª–µ–Ω–∏–π (120¬∞) ‚Üí —á–µ—Ä–≤–æ–Ω–∏–π (0¬∞)
  const hue = (1 - ratio) * 120; 
  return `hsl(${hue}, 70%, 45%)`;
}

function renderTable(partners) {
  const table = document.getElementById("planTableBody");
  table.innerHTML = "";

  partners.forEach(p => {
    p.products.forEach(prod => {
      const row = document.createElement("tr");

      // –ø–ª–∞–Ω
      const planCell = document.createElement("td");
      planCell.textContent = prod.planPacks;
      row.appendChild(planCell);

      // –≤–∏–∫–æ–Ω–∞–Ω–æ
      const execCell = document.createElement("td");
      execCell.textContent = prod.execPacks;
      row.appendChild(execCell);

      // –¥–æ–ø—Ä–æ–¥–∞—Ç–∏
      const toSellCell = document.createElement("td");
      toSellCell.textContent = prod.toSellPacks;
      toSellCell.classList.add("to-sell");
      toSellCell.style.backgroundColor = getColorForToSell(prod.toSellPacks, prod.planPacks);
      row.appendChild(toSellCell);

      table.appendChild(row);
    });
  });
}


// –í–∏–∫–ª–∏–∫ –ø—Ä–∏ –Ω–∞—Ç–∏—Å–∫–∞–Ω–Ω—ñ
document.getElementById("calcBtn").addEventListener("click", async () => {
  const quarter = document.getElementById("quarterSelect").value;
  const historyType = document.getElementById("historyType").value;
  const partnerId = parseInt(document.getElementById("partnerSelect").value);
  const user = document.getElementById("userSelect").value;

  if (partnerId === "all") {
    alert("–û–±–µ—Ä—ñ—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –ø–∞—Ä—Ç–Ω–µ—Ä–∞!");
    return;
  }

  const partners = JSON.parse(localStorage.getItem("partners")) || [];
  const historyUrl = getHistoryUrl(user);

  // 1. –ø—ñ–¥—Ç—è–≥–Ω—É—Ç–∏ —ñ—Å—Ç–æ—Ä—ñ—é –ø–æ –í–°–Ü–• –ø–∞—Ä—Ç–Ω–µ—Ä–∞—Ö —Ü—å–æ–≥–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
  const ids = userMap[user] || [];
  let allPartners = [];
  for (let id of ids) {
    const products = await fetchHistory(id, historyUrl, partners);
    const d = partners.find(p => p.id === id);
    if (!d) continue;

    let partnerObj = {
      id: d.id,
      name: d.name,
      turnover: d.turnover,
      msTable: d.msTable || 0,
      grossRate: d.grossRate || 0,
      ei: d.ei || 0,
      tt: d.tt || 0,
      products: products
    };

    allPartners.push(partnerObj);
  }

partners.forEach(p => {
  if (!Array.isArray(p.products)) {
   //onsole.warn("‚ñ∂ –£ –ø–∞—Ä—Ç–Ω–µ—Ä–∞ –Ω–µ–º–∞—î products:", p.id, p.name);
    return;
  }

  p.products.forEach(prod => {
    console.log("‚ñ∂ –ü—Ä–æ–¥—É–∫—Ç:", prod.product);
    console.log("‚ñ∂ –ö–ª—é—á—ñ historyMoney:", Object.keys(prod.historyMoney || {}));
    console.log("‚ñ∂ –ö–ª—é—á—ñ historyPacks:", Object.keys(prod.historyPacks || {}));
  });
});

  // 2. —Ä–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ MS—Ä –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ –ø–∞—Ä—Ç–Ω–µ—Ä–∞
  const totalUserTurnover = allPartners.reduce((sum, p) => sum + p.turnover, 0);
  allPartners.forEach(p => {
    p.msr = totalUserTurnover > 0 ? (p.turnover / totalUserTurnover * 100) : 0;
    const {type, cls} = classifyPartner(p, allPartners);
    p.type = type;
    p.cls = cls;
  });

  // 3. —Ç—è–≥–Ω–µ–º–æ –ø–ª–∞–Ω–∏ (Oleksandr = fedir, Tetiana = olena)
  const planUrlOleksandr = "https://docs.google.com/spreadsheets/d/1TtDl9d1rxAl7mCwlW7N6plVhxZYAVEk8";
  const planUrlTetiana   = "https://docs.google.com/spreadsheets/d/1IKqln_4KSXwcTiikO48E6j3XywHoebhI";
  const plans = user === "fedir" ? await fetchPlan(planUrlOleksandr) : await fetchPlan(planUrlTetiana);

  // 4. —Ä–æ–∑–ø–æ–¥—ñ–ª –ø–ª–∞–Ω—É –º—ñ–∂ —É—Å—ñ–º–∞ –ø–∞—Ä—Ç–Ω–µ—Ä–∞–º–∏ —Ü—å–æ–≥–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
  const result = distributePlanForPartners(plans, allPartners, quarter);

  // 5. —Ä–µ–Ω–¥–µ—Ä–∏–º–æ –ª–∏—à–µ –æ–±—Ä–∞–Ω–æ–≥–æ –ø–∞—Ä—Ç–Ω–µ—Ä–∞
  const selectedPartner = result.find(p => p.id === partnerId);
  renderAllPartnersClassification(allPartners);
  renderClassification([selectedPartner]);
  renderHistoryPlans([selectedPartner], quarter, historyType);


 // 6. –ø–æ–∫–∞–∑—É—î–º–æ —Å—É–º–∏ –ø–æ —ñ—Å—Ç–æ—Ä—ñ—ó, –ø–ª–∞–Ω—É —ñ –≤–∏–∫–æ–Ω–∞–Ω–Ω—é –¥–ª—è —Ü—å–æ–≥–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
const totals = calculateUserTotals(plans, allPartners, quarter, user);
const name = userNames[user];

document.getElementById("totals").innerHTML =
  `<h3>–°—É–º–∏ –¥–ª—è ${name}</h3>
   <p>–Ü—Å—Ç–æ—Ä—ñ—è ${quarter} 2025: ${totals.totalHistory}</p>
   <p>–ü–ª–∞–Ω ${quarter} 2026: ${totals.totalPlan}</p>
   <p>–í–∏–∫–æ–Ω–∞–Ω–æ ${quarter} 2026: ${totals.totalExec}</p>
   <p>% –≤–∏–∫–æ–Ω–∞–Ω–Ω—è: ${totals.percentExec}%</p>`;

   // 7. —Ä–µ–Ω–¥–µ—Ä–∏–º–æ –≥—Ä–∞—Ñ—ñ–∫ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è –ø–æ –ø—Ä–æ–¥—É–∫—Ç–∞—Ö
renderPlanChart(plans, allPartners, quarter, user);

});

// –∞–≤—Ç–æ—ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –ø—Ä–∏ —Å—Ç–∞—Ä—Ç—ñ
const user = document.getElementById("userSelect").value;
initPartners(user);

// –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –ø—Ä–∏ –∑–º—ñ–Ω—ñ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
document.getElementById("userSelect").addEventListener("change", e => {
  initPartners(e.target.value);
});

</script>
</body>
</html>
